from random import randint, choice, shuffle
from treelib import Tree
from .echo_process import EchoProcess
from .message_manager import MessageManager
import networkx as nx
import matplotlib.pyplot as plt

msg_manager = MessageManager(delay_msg=True)
logs = []


def log(msg):
    logs.append(msg)


def generate_processes(num_processes: int, display=False) -> list:
    assert num_processes >= 2

    # Graph
    g = nx.Graph()

    # Create a tree
    processes = [EchoProcess(1, msg_manager)]
    nodes = [EchoProcess(x, msg_manager) for x in range(2, num_processes + 1)]

    while len(nodes) > 0:
        # Pick random node
        i = randint(0, len(nodes) - 1)
        current_node = nodes[i]

        # Pick random parent
        parent = choice(processes)
        parent.add_neigh(current_node.p_id)
        current_node.add_neigh(parent.p_id)

        # Add edge to graph
        g.add_edge(current_node.p_id, parent.p_id)

        # Add process to processes
        processes += [current_node]

        # Remove from nodes to add
        del nodes[i]

    shuffle(processes)

    # Add additional random edges
    for process in processes:
        available = [q for q in processes if q != process and q.p_id not in process.neigh]
        shuffle(available)
        for i in range(randint(0, len(available) // 2)):
            # Add neighbour to processes
            process.add_neigh(available[i].p_id)
            available[i].add_neigh(process.p_id)

            # Add edge to graph
            g.add_edge(process.p_id, available[i].p_id)

    shuffle(processes)

    if display:
        # Display the generated graph
        nx.draw_networkx(g)
        plt.title("Network before echo algorithm")
        plt.show()

    return processes


def find_tree(processes: dict, initiator: EchoProcess, display=False) -> Tree:
    g = nx.Graph()  # Graph for matplot
    tree = Tree()  # Tree for console

    # Add root node
    visited = []
    queue = [initiator]

    while len(queue) > 0:
        node = queue[0]
        del queue[0]
        if node.father:
            if node.father not in visited:
                continue  # Wait until father is added
            tree.create_node(str(node), str(node), parent=str(processes[node.father]))
            g.add_edge(node.p_id, node.father)
        else:
            tree.create_node(str(node), str(node))
        for n in node.neigh:
            if n not in visited and processes[n] not in queue:
                queue.append(processes[n])
        visited.append(node.p_id)

    if display:
        # Display the tree
        nx.draw_networkx(g)
        plt.title("Tree generated by echo algorithm")
        plt.show()

    return tree


def run_echo_algorithm():
    processes = generate_processes(8, display=True)

    # Initialise message manager and processes
    msg_manager.initialise(processes)
    initiator = None
    for process in processes:
        if not initiator:
            # Create initiator
            process.initialise(initiator=True)
            initiator = process
        else:
            # Initialise non-initiator
            process.initialise()

    while not initiator.decide:
        # Wait until initiator has decided
        pass

    # Display logs
    print("Logs from processes:")
    print('\n'.join(logs))
    print()

    # Display tree generated by echo algorithm
    print("Tree produced by echo algorithm from processes:")
    tree = find_tree({p.p_id: p for p in processes}, initiator, display=True)
    tree.show()
